# 第三次实验

## 实验一

### 题目

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713140709429.png" alt="image-20240713140709429" style="zoom:33%;" />

具体代码为：

```py
import numpy as np 
from scipy.optimize import minimize 

# 定义对数似然函数，增加 epsilon 以避免除零错误 
def log_likelihood(r, x1, x2):
    epsilon = 1e-10 # 一个非常小的数，防止除零错误
    n = len(x1)
    term1 = -n * np.log(2 * np.pi * np.sqrt(1 - r**2 + epsilon))
    term2 = -1 / (2 * (1 - r**2 + epsilon)) * np.sum(x1**2 - 2 * r * x1 * x2 + x2**2)
    return -(term1 + term2) 

# 样本点 
x1, x2 = 1, 2 

# 使用优化函数来最大化对数似然函数
result = minimize(log_likelihood, 0, args=(np.array([x1]), np.array([x2])), bounds=[(-1, 1)])
r_estimate = result.x[0]

r_estimate

```

### 实验结果

$$
r =0.6388969120173674
$$

## 实验二

### 题目

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713141138810.png" alt="image-20240713141138810" style="zoom:33%;" />

### 具体代码

```py
import numpy as np from sklearn.gaussian_process
import GaussianProcessRegressor from sklearn.gaussian_process.kernels 
import RBF, ConstantKernel as C 
import matplotlib.pyplot as plt 

# 定义响应函数 
def response_function(t): 
    return np.sum(t**2 - 10 * np.cos(2 * np.pi * t) + 10)

# 生成数据 
np.random.seed(0) 
T = np.random.uniform(-20, 20, (200, 10)) 
X = np.array([response_function(t) for t in T]) 

# 构建高斯过程模型 
kernel = C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2)) 
gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10) 
gp.fit(T, X) 

# 随机生成一个新的 t0 
t0 = np.random.uniform(-20, 20, 10) 
X_t0_true = response_function(t0) 

# 用高斯过程模型进行预测 
X_t0_pred, sigma = gp.predict(t0.reshape(1, -1), return_std=True) 

# 计算误差 
error = (X_t0_true - X_t0_pred)**2 

# 打印结果 
print("True value:", X_t0_true) 42 
print("Predicted value:", X_t0_pred) 
print("Prediction error:", error) 

# 可视化 
plt.figure(figsize=(10, 6))
plt.errorbar(np.arange(10), t0, yerr=sigma, fmt='o', label='Predicted')
plt.axhline(X_t0_true, color='r', linestyle='--', label='True value')
plt.xlabel('t index')
plt.ylabel('t value')
plt.title('Prediction vs True value')
plt.legend()
plt.show()
```

### 实验结果

![image-20240713141633206](./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713141633206.png)

# 第四次实验

## 书本实验 1

### 具体代码

```py 
import numpy as np
import scipy as sp
import pylab as pl from scipy.optimize
import leastsq #引入最小二乘函数

#多项式次数 
n=9

#目标函数
def real_func(x): 
    #目标函数:sin(2*pi*x)
    return np.sin(2 * np.pi * x)

#定义多项式函数，用多项式去拟合数据: 
def fit_func(p, x): 
    f = np.poly1d(p)
    return f(x) 

#定义残差函数，残差函数值为多项式拟合结果与真实值的差值: 
def residuals_func(p,Y,x):
    ret= fit_func(p,x)-Y
    return ret

x=np.linspace(0,1,9) # 随机选择 9 个点作为 x 
x_points =np.linspace(0,1,1000) # 画图时需要的连续点 
y0 = real_func(x) # 目标所数
y1 = [np.random.normal(0,0.1)+y for y in y0] # 在目标函数上添加符合正态分布 噪声后的函数
p_init = np.random.randn(n) # 随机初始化多项式参数 

# 调用 scipy.optimize 中的 leastsq 函数，通过最小化误差的平方和来寻找最佳的 匹配函数 
#func 是一个残差函数，x0 是计算的初始参数值，把残差函数中除了初始化以外的参 数打包到 args 中

plsq= leastsq(func=residuals_func, x0=p_init, args=(y1, x))
print('Fitting Parameters: ',plsq[0])#输出拟合参数
pl.plot(x_points, real_func(x_points), label='real')
pl.plot(x_points, fit_func(plsq[0], x_points), label='fitted curve')
pl.plot(x,y1,'bo',label='with noise')
pl.legend()
pl.show() 
```

### 实验结果

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713142615585.png" alt="image-20240713142615585" style="zoom:33%;" />

### 书本实验

### 具体代码

```py
#y[i] 样本点对应的输出 
x=[(1,0.,3),(1,1.,3),(1,2.,3),(1,3.,2),(1,4.,4)]
y=[95.364,97.217205,75.195834,60.105519,49.342380]

#迭代阀值，当两次迭代损失函数之差小于该阀值时停止迭代
epsilon =0.0001

#学习率
alpha =0.01

diff =[0,0]
max_itor = 1000
error1 = 0
error0 = 0
cnt = 0
m = len(x) 

#初始化参数 
theta0 =0
theta1 =0
theta2 =0 
while True:
    cnt += 1 
    # 參数迭代计算 
    for i in range(m): 
        #拟合数为 y= theta0 * x[0]+ theta1 * x[1] +theta2 * x[2] 
        #计算残差，即拟合函数值-真实值
        diff[0]=(theta0* x[i][0] + theta1 * x[i][1] + theta2 * x[i][2])-y[i] 
        # 梯度 = di££[0]* x[i][j]。根据步长*梯度更新参数
        theta0 -= alpha * diff[0]* x[i][0]
        theta1 -= alpha * diff[0]* x[i][1]
        theta2 -= alpha * diff[0]* x[i][2]
        
    # 计算损失函数 
    error1=0 
    for lp in range(len(x)): 
        error1 +=(y[lp]-(theta0* x[lp][0]+ theta1 * x[lp][1] + theta2 * x[lp][2]))**2/2 
        
    #若当两次迭代损失函数之差小于该阀值时停止选代，跳出循环 
    if abs(error1-error0)< epsilon: 
        break 
    else: 
        error0 = error1 

print('theta0 : %f, theta1 : %f, theta2 : %f, error1 : %f'% (theta0,theta1,theta2,error1)) 
print('Done: theta0 : %f, theta1 : %f, theta2 : %f'% (theta0, theta1,theta2))
print('迭代次数:%d'%cnt) 
```

### 实验结果

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713143126483.png" alt="image-20240713143126483" style="zoom:33%;" />

## 用凸优化以及数学优化工具库方法求解问题

### 优化问题 1

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713143206391.png" alt="image-20240713143206391" style="zoom:50%;" />

#### 数学优化工具库求解

```py
import numpy as np from scipy.optimize
import minimize

# 定义目标函数 
def objective(x): 
    return 2*x[0]**2 + x[1]**2 + x[2]**2 

# 定义约束条件 
cons = ( 
    {'type': 'ineq', 'fun': lambda, x: -(x[0]**2 + x[1]**2 - 4)}, 
    {'type': 'eq', 'fun': lambda x: 5*x[0] - 4*x[1] - 8},
    {'type': 'ineq', 'fun': lambda x: x[0]},
    {'type': 'ineq', 'fun': lambda x: x[1]},
    {'type': 'ineq', 'fun': lambda x: x[2]} ) 

# 初始猜测 
x0 = np.array([1, 1, 1]) 
# 求解 
result = minimize(objective, x0, constraints=cons) 
print(result) 
```

#### 实验结果分析

由实验结果可知，优化成功终止，说明找到了解的最优解，最优目标函数值为 5.12， 最优解为$[1.6,6.661e^{−15},1.554e^{−15}]$。由于$6.661e^{−15}$ 和 $1.554e^{−15}$非常接近于零，可以认为 $x_1$ 和 $x_2$ 都是零；优化过程共进行了 2 次迭代；目标函数在最优解处的梯度为 $[6.4,0,0]$；目标函数被调用了 8 次；梯度函数被调用了 2 次。

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713145538312.png" alt="image-20240713145538312" style="zoom: 50%;" />

#### 用凸优化工具库 cvxpy 求解

```py
 #用凸优化工具库求解
import cvxpy as cp 

# 定义变量
x1 = cp.Variable()
x2 = cp.Variable()
x3 = cp.Variable() 

# 定义目标函数 
objective = cp.Minimize(2*x1**2 + x2**2 + x3**2) 

# 定义约束条件
constraints = [ 
    x1**2 + x2**2 <= 4,
    5*x1 - 4*x2 == 8,
    x1 >= 0, x2 >= 0,
    x3 >= 0
] 

# 定义问题
prob = cp.Problem(objective, constraints) 

# 求解 
result = prob.solve()
print(f"Optimal value: {result}")
print(f"x1: {x1.value}, x2: {x2.value}, x3: {x3.value}") 
```

#### 实验结果及分析

从输出结果来看，最优值为 $5.119999975530055$，表示在给定的约束条件下， 目标函数 $2x_{12}+x_{22}+x_{32}$ 的最小值。

变量值：$x_1≈1.6$，满足约束条件 $5x_1−4x_2=8$ 和 $x_{12}+x_{22}≤4$。$x_2≈0$ 由于 $x_2$ 非负且接近于 0，满足约束条件。$x_3≈0$由于 $x_3$ 非负且接近于 0， 满足约束条件。并且输出结果与使用数学优化工具库求出的结果一致。

### 优化问题 2 

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713150217099.png" alt="image-20240713150217099" style="zoom:33%;" />

#### 用数学优化工具库求解 

```py
import numpy as np from scipy.optimize
import minimize

# 定义目标函数 
def objective(x):
    return x[0]**2 - x[1]**2 - x[2]**2 

# 定义约束条件 
cons = ( 
    {'type': 'ineq', 'fun': lambda, x: -(x[0]**2 + x[1]**2 - 4)}, 
    {'type': 'eq', 'fun': lambda, x: 5*x[0] - 4*x[1] - 8}, 
    {'type': 'ineq', 'fun': lambda, x: x[0]}, 
    {'type': 'ineq', 'fun': lambda, x: x[1]}, 
    {'type': 'ineq', 'fun': lambda, x: x[2]} ) 

# 初始猜测 
x0 = np.array([1, 1, 1]) 

# 求解
result = minimize(objective, x0, constraints=cons)
print(result) 
```

#### 实验结果

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713150512176.png" alt="image-20240713150512176" style="zoom: 50%;" />

从输出结果来看，优化过程没有成功，主要原因是约束条件不兼容。具体分析如下： 

* `message: Inequality constraints incompatible`这个信息表明不等式约束条件之间存在冲突，导致优化问题无法找到可行解。 

* `success: False` 这个标志表明优化过程没有成功。

* `status: 4` 状态码 4 表示优化过程由于约束条件不兼容而失败。 

* `fun: -6.742189191122648e+79`目标函数的值非常大，表明优化过程可能在尝试找到解的过程中遇到了数值问题。 

* `x: [9.461e+14, 1.183e+15, 8.211e+39]` 变量的值非常大，进一步表明优化过程可能在尝试找到解的过程中遇到了数值问题。

* `nit: 16` 优化过程进行了 16 次迭代。

* `jac: [0.000e+00, 0.000e+00, -1.642e+40]` 目标函数在解处的梯度值。 

* `nfev: 60` 目标函数被评估了 60 次。

* `njev: 15` 目标函数的梯度被评估了 15 次。

####  用凸优化 cvxpy 工具库求解

```py
#用凸优化工具求解
import cvxpy as cp

# 定义变量
x1 = cp.Variable()
x2 = cp.Variable()
x3 = cp.Variable() 

# 定义目标函数
objective = cp.Minimize(2 * cp.square(x1) - cp.square(x2) - cp.square(x3)) 

# 定义约束条件
constraints = [
    cp.square(x1) + cp.square(x2) <= 4,
    5 * x1 - 4 * x2 == 8,
    x1 >= 0,
    x2 >= 0,
    x3 >= 0 
] 

# 定义问题
prob = cp.Problem(objective, constraints)

# 求解
result = prob.solve()
print(f"Optimal value: {result}")
print(f"x1: {x1.value}, x2: {x2.value}, x3: {x3.value}") 
```



实验结果

出现了报错，但这很正常，因为这道题中的函数不是凸函数，不满足凸优化条件。

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713151049824.png" alt="image-20240713151049824" style="zoom:33%;" />

### 优化问题 3

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713152917220.png" alt="image-20240713152917220" style="zoom: 50%;" />

#### 用数学优化工具库求解

```py
from scipy.optimize import minimize
import numpy as np

# 定义目标函数 
def objective(x):
    return np.sum(np.abs(x))

# 定义约束条件 
def constraint1(x):
    return x[0] + x[1] + x[2] - 1

def constraint2(x):
    return 2 - (x[0]**2 + x[1]**2 + x[2]**2) 

# 定义变量的界限
bounds = [(-1, 1), (-1, 1), (-1, 1)]

# 初始猜测
x0 = [0, 0, 0]

# 定义约束
constraints = [
    {'type': 'eq', 'fun': constraint1}, 
    {'type': 'ineq', 'fun': constraint2}] 

# 求解问题
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)

# 输出结果
print("Optimal value:", solution.fun)
print("Optimal x1:", solution.x[0])
print("Optimal x2:", solution.x[1])
print("Optimal x3:", solution.x[2]) 
```

#### 实验结果

通过使用 `scipy.optimize` 库中的 `minimize` 函数，我们对一个带有约 束条件的优化问题进行了求解。 最优目标值接近于 1，这表明在满足约束条件的情况下，绝对值之和的最小 值为 1。 最优解中的每个变量值都接近于 1/3，这符合约束条件 $x_1+x_2+x_3 = 1$​。

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713152838159.png" alt="image-20240713152838159" style="zoom: 50%;" />

#### 用凸优化 cvxpy`工具库求解 

```py
import cvxpy as cp 

# 定义变量 
x1 = cp.Variable() 
x2 = cp.Variable() 
x3 = cp.Variable() 

# 定义目标函数 
objective = cp.Minimize(cp.norm1(cp.hstack([x1, x2, x3]))) 

# 定义约束条件 
constraints = [ 
    x1**2 + x2**2 + x3**2 <= 2, 
    x1 + x2 + x3 == 1, 
    52 -1 <= x1, 
    x1 <= 1, 
    -1 <= x2, 
    x2 <= 1, 
    -1 <= x3, 
    x3 <= 1 
] 

# 定义问题 
problem = cp.Problem(objective, constraints) 

# 求解问题 
problem.solve() 

# 输出结果 
print("Optimal value:", problem.value) 
print("Optimal x1:", x1.value) 
print("Optimal x2:", x2.value) 
print("Optimal x3:", x3.value)
```



#### 实验结果及分析 

通过凸优化工具库 CVXPY，我们成功地求解了这个优化问题。结果表明，在满足所有约束条件的情况下，$x_1$, $x_2$ 和 $x_3$ 的最优值使得目标函数（$L_1$ 范 数）最小化，并且这些值都接近于 1/3。

这与用数学优化工具库求解结果一致。 

<img src="./%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/image-20240713153450386.png" alt="image-20240713153450386" style="zoom: 50%;" />

### 优化问题

#### 用数学优化工具库求解

```py
from scipy.optimize import minimize 
import numpy as np 

# 定义目标函数 
def objective(x): 
    return np.max(np.abs(x)) 

# 定义约束条件 
def constraint1(x): 
    return 2 - np.sum(x**2) 

def constraint2(x): 
    return np.sum(x) - 1 

# 定义边界 
bounds = [(-1, 1), (-1, 1), (-1, 1)] 

# 定义初始猜测 
x0 = [0, 0, 0] 

# 定义约束 
constraints = [ 
    {'type': 'ineq', 'fun': constraint1}, 
    {'type': 'eq', 'fun': constraint2} 
]
# 求解问题 
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints) 
# 输出结果 
print("Optimal value:", solution.fun) 
print("Optimal x:", solution.x)
```

#### 实验结果

通过 `scipy.optimize.minimize` 求解的结果显示，最优解 x 为 $[0.33333333, 0.33333333, 0.33333333]$，此时目标函数的值 为 $0.3333333333333335$，并且满足所有的约束条件。这个结果是合理的，因为 在满足约束条件的情况下，目标函数的最小值确实是 $0.3333333333333335$。 

#### 用凸优化 cvxpy 工具库求解 

```py
import cvxpy as cp

# 定义变量 
x1 = cp.Variable()
x2 = cp.Variable()
x3 = cp.Variable() 

# 定义目标函数 
objective = cp.Minimize(cp.norm_inf(cp.hstack([x1, x2, x3]))) 

# 定义约束条件 
constraints = [ 
    x1**2 + x2**2 + x3**2 <= 2, 
    x1 + x2 + x3 == 1, 
    x1 >= -1, 
    x1 <= 1, 
    x2 >= -1, 
    x2 <= 1, 
    x3 >= -1, 
    x3 <= 1 
] 

# 定义问题 
prob = cp.Problem(objective, constraints) 

# 求解 
result = prob.solve() 
print(f"Optimal value: {result}") 
print(f"x1: {x1.value}, x2: {x2.value}, x3: {x3.value}") 
```

通过凸优化工具库 `CVXPY` 求解该问题，得到了最优解 $x_1=x_2=x_3=0.33333333333333309$，并且最优值为 $0.33333333333333309$。这个结果满足所有给定的约束条件，并且使目标函数（无穷范数）最小化。与用数学优化工具库求解的结果一致。
